"""Defines a function which can be used to initialize the callbacks used in
the route finder page"""

from typing import Dict, List, Callable, Union, Tuple
from dash import callback, Input, Output, State, no_update, html
from dash.development.base_component import Component
from dash._callback import NoUpdate
from plotly.graph_objects import Figure
import dash_leaflet as dl

from fell_finder.routing.containers import RouteConfig
from fell_finder import app_config
from fell_finder.routing import RouteMaker
from fell_finder.app.content.route_finder.generators import (
    generate_elevation_plot,
    generate_progress_bar,
    generate_route_card,
)
from fell_finder.app.utils.caching import (
    store_routes_to_str,
    load_routes_from_str,
)
from fell_finder.app.utils.plotting import (
    generate_polyline_from_route,
    finalize_route,
)
from fell_finder.app.app import background_callback_manager


def init_callbacks() -> None:
    """This function needs to be called in a function which defines elements of
    the page config in order to ensure the enclosed callbacks are correctly
    registered"""

    # ruff: noqa: ANN202

    @callback(
        Output("route-plot", "children", allow_duplicate=True),
        Input("route-plot", "clickData"),
        State("route-plot", "children"),
        prevent_initial_call=True,
    )
    def show_clicked_point_on_map(click_data: Dict, current_children: List):
        """Whenever the user clicks a point on the route, add a marker to the
        map at the selected point

        Args:
            click_data: The data generated by Dash to signify a user click
            current_children: The current contents of the primary plot

        Returns:
            The updated contents of the route plot, with the old marker removed
            and a new one added
        """
        if click_data is None:
            return no_update

        lat = click_data["latlng"]["lat"]
        lon = click_data["latlng"]["lng"]

        new_marker = dl.Marker(position=[lat, lon], id="route-plot-marker")

        new_children = [
            child
            for child in current_children
            if child["props"]["id"] != "route-plot-marker"
        ]
        new_children.append(new_marker)

        return new_children

    @callback(
        [
            Output("route-store", "data", allow_duplicate=True),
            Output("url", "search"),
        ],
        Input("route-calculate", "n_clicks"),
        [
            State("route-plot", "children"),
            State("route-dist", "value"),
            State("route-mode", "value"),
            State("route-highway", "value"),
            State("route-surface", "value"),
        ],
        background=True,
        prevent_initial_call=True,
        progress=Output("progress-bar", "children"),
        manager=background_callback_manager,
    )
    def calculate_and_store_routes(
        set_progress: Callable,
        n_clicks: Union[int, None],
        current_children: List,
        route_dist: str,
        route_mode: str,
        route_highways: List[str],
        route_surfaces: List[str],
    ) -> Union[Tuple[List[str], str], Tuple[NoUpdate, NoUpdate]]:
        """Based on the user's selection, generate a circular route which meets
        their requirements. Periodically update the progress bar to keep them
        informed.

        Args:
            set_progress: Function provided by dash which can be used to update
              the progress bar as the function executes
            n_clicks: The number of times the calculate button has been clicked
            current_children: The contents of the current route plot
            route_dist: The user requested distance
            route_mode: The user requested mode
            route_highways: The user requested highways
            route_surfaces: The user requested surfaces

        Returns:
            A circular route starting at the selected point
        """
        if not n_clicks:
            return no_update, no_update

        current_marker = next(
            x
            for x in current_children
            if x["props"]["id"] == "route-plot-marker"
        )
        lat, lon = current_marker["props"]["position"]

        max_candidates = app_config["routing"]["max_candidates"]

        highway_types = []
        for highway_type in route_highways:
            highway_types += app_config["highway_types"][highway_type]

        surface_types = []
        for surface_type in route_surfaces:
            surface_types += app_config["surface_types"][surface_type]

        config = RouteConfig(
            start_lat=lat,
            start_lon=lon,
            target_distance=int(route_dist) * 1000,
            route_mode=route_mode,
            max_candidates=app_config["routing"]["max_candidates"],
            tolerance=0.1,
            highway_types=highway_types,
            surface_types=surface_types,
        )

        no_attempts = 0
        routes = []
        while len(routes) == 0 and no_attempts < 4:
            config.max_candidates = max_candidates * (2 * (no_attempts + 1))

            maker = RouteMaker(config, app_config["data_dir"])
            for progress, attempt_routes in maker.find_routes():
                set_progress(
                    generate_progress_bar(
                        cur_val=progress["avg_distance"],
                        max_val=progress["max_distance"],
                        attempt=no_attempts,
                        valid_routes=progress["n_valid"],
                    )
                )

                if attempt_routes is not None:
                    routes = attempt_routes

            no_attempts += 1

        if not routes:
            # TODO: Set a proper message explaining that no routes were found
            return no_update, no_update

        routes = routes[:25]
        graph = maker.graph

        routes = [finalize_route(graph, route) for route in routes]

        routes_str = store_routes_to_str(routes)

        route_id = routes[0].route_id
        query_str = f"?route_id={route_id}"

        return [routes_str], query_str

    @callback(
        [
            Output("route-plot", "children", allow_duplicate=True),
            Output("route-plot", "viewport"),
            Output("route-profile", "figure"),
        ],
        [Input("url", "search")],
        [
            State("route-store", "data"),
            State("route-plot", "children"),
            State("url", "pathname"),
        ],
        prevent_initial_call=True,
    )
    def update_primary_plot(
        search_str: str,
        cached_routes: str,
        current_children: List,
        current_page: str,
    ) -> Union[Tuple[NoUpdate, NoUpdate, NoUpdate], Tuple[List, Dict, Figure]]:
        """When the user selects a new route for display in the primary plot,
        fetch the relevant data and render it as a polyline

        Args:
            search_str: The requested route ID
            cached_routes: The cached route data
            current_children: The current contents of the primary plot
            current_page: The currently selected page

        Returns:
            The updated contents of the primary plot, with any old polylines
            removed and a new one added
        """

        if current_page != "/route_finder":
            return no_update, no_update, no_update

        if not cached_routes:
            return no_update, no_update, no_update

        routes = load_routes_from_str(cached_routes[0])

        if not search_str:
            # User hasn't clicked a route yet, display the first
            route = routes[0]
        else:
            # Display the selected route
            target_id = search_str.split("=")[-1]
            route = next(x for x in routes if x.route_id == target_id)

        polyline = generate_polyline_from_route(route)

        bounds = {"bounds": route.bounds, "center": route.centre}

        new_children = [
            x
            for x in current_children
            if x["props"]["id"] != "route-plot-trace"
        ]
        new_children.append(polyline)

        profile_plot = generate_elevation_plot(route)

        return new_children, bounds, profile_plot

    @callback(
        Output("route-cards", "children"),
        Input("route-store", "data"),
        prevent_initial_call=True,
    )
    def update_route_cards(
        cached_routes: str,
    ) -> Union[List[Component], html.Div]:
        """When new map data is added to the store, render a small card for
        each route which includes a mini-map and a link to view it in more
        detail

        Args:
            cached_routes: The cached route data

        Returns:
            A list of route card elements"""
        if not cached_routes:
            return html.Div()

        routes = load_routes_from_str(cached_routes[0])

        route_cards = []
        for route in routes:
            route_card = generate_route_card(route)
            route_cards.append(route_card)

        return route_cards

    @callback(
        Output("route-plot", "children", allow_duplicate=True),
        Input("route-profile", "hoverData"),
        State("route-plot", "children"),
        prevent_initial_call=True,
    )
    def update_map_based_on_profile(
        hover_data: Union[Dict, None], current_children: List
    ):
        """When the user hovers over the elevation profile, place a marker on
        the map at the corresponding location.

        Args:
            hover_data: Data on the currently selected point on the profile
            current_children: The current contents of the route plot

        Returns:
            The different layers required to plot the route and the selected
            point on the map
        """
        if hover_data is None:
            return no_update

        lat_lon = hover_data["points"][0]["customdata"]

        route_marker = dl.Marker(position=lat_lon, id="selected-point")

        new_children = [
            x for x in current_children if x["props"]["id"] != "selected-point"
        ]

        new_children.append(route_marker)

        return new_children

    @callback(
        Output("route-dist-display", "children"), Input("route-dist", "value")
    )
    def update_route_dist_display(selected_dist: str):
        """When the user changes the selected distance, update the indicator to
        reflect the new value.

        Args:
            selected_dist: The user selected distance

        Returns:
            A string representation of selected_dist"""

        output = f"{selected_dist} km"

        return output

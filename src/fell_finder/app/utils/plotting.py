"""Utility functions which either help to extract data which is helpful for
plotting, or generate plots which are featured on more than one page"""

from dataclasses import dataclass
from typing import List, Tuple

import dash_leaflet as dl
from rustworkx import PyDiGraph

from fell_finder.routing.containers import Route


@dataclass
class RouteGeometry:
    """Class representing the physical geometry of a route"""

    lats: List[float]
    lons: List[float]
    elevations: List[float]
    distances: List[float]
    points: List[int]


def get_geometry_from_route(graph: PyDiGraph, route: Route) -> RouteGeometry:
    """For a generated route, generate a dash-leaflet polyline which can be
    displayed on a map

    Args:
        graph: The graph which was used to generate the provided route
        route: A route generated by a RouteMaker

    Returns:
        A dictionary containing a list of points for lats, lons, elevations
        and distances
    """
    lats = []
    lons = []
    elevations = []
    distances = []

    last_id = None
    cur_dist = 0.0
    for node_id in route.route:
        if last_id is not None:
            last_edge = graph.get_edge_data(last_id, node_id)
            geometry = last_edge.geometry

            lats += geometry["lat"]
            lons += geometry["lon"]
            elevations += geometry["elevation"]
            for step_dist in geometry["distance"]:
                cur_dist += step_dist
                distances.append(cur_dist)

        last_id = node_id

    route_geometry = RouteGeometry(
        lats=lats,
        lons=lons,
        elevations=elevations,
        distances=distances,
        points=route.route,
    )

    return route_geometry


@dataclass
class CompletedRoute:
    """Class representing a completed route"""

    lats: List[float]
    lons: List[float]
    elevations: List[float]
    distances: List[float]

    route_id: str
    distance: float
    elevation_gain: float
    elevation_loss: float

    @property
    def max_lat(self) -> float:
        """The max latitude visited at any point in the route"""
        return max(self.lats)

    @property
    def max_lon(self) -> float:
        """The max longitude visited at any point in the route"""
        return max(self.lons)

    @property
    def min_lat(self) -> float:
        """The min latitude visited at any point in the route"""
        return min(self.lats)

    @property
    def min_lon(self) -> float:
        """The max longitude visited at any point in the route"""
        return min(self.lons)

    @property
    def centre(self) -> Tuple[float, float]:
        """Returns the coordinates representing the centre of the route"""
        mid_lat = self.max_lat - ((self.max_lat - self.min_lat) / 2)
        mid_lon = self.max_lon - ((self.max_lon - self.min_lon) / 2)

        return mid_lat, mid_lon

    @property
    def bounds(self) -> Tuple[Tuple[float, float], Tuple[float, float]]:
        """Returns the pair of coordinates representing the bounds of the
        area covered by the route"""
        return ((self.min_lat, self.max_lon), (self.max_lat, self.min_lon))


def finalize_route(graph: PyDiGraph, route: Route) -> CompletedRoute:
    """Fetch any information about the route which requires that the graph
    object which created it be persisted in memory and store it down into
    a new CompletedRoute object

    Args:
        graph: A rustworkx graph which was used to create a route
        route: The created route

    Returns:
        A completed route, with information about the route geometry saved
        as an internal attribute"""
    route_geo = get_geometry_from_route(graph, route)

    completed_route = CompletedRoute(
        route_geo.lats,
        route_geo.lons,
        route_geo.elevations,
        route_geo.distances,
        route.route_id,
        route.distance,
        route.elevation_gain,
        route.elevation_loss,
    )

    return completed_route


@dataclass
class ElevationData:
    """Class representing the elevation profile of a route"""

    distance: List[float]
    elevation: List[float]
    coordinates: List[Tuple[float, float]]
    total_distance: float
    total_elevation: float


def get_elevation_data_from_route(route: CompletedRoute) -> ElevationData:
    """For a generated route, generate a plotly graph which displays the
    elevation profile.

    Args:
        graph: The graph which was used to generate the provided route
        route: A route generated by a RouteMaker"""

    distance = route.distances
    elevation = route.elevations
    coords = [(lat, lon) for lat, lon in zip(route.lats, route.lons)]

    total_distance = route.distance
    total_elevation = route.elevation_gain

    data = ElevationData(
        distance=distance,
        elevation=elevation,
        coordinates=coords,
        total_distance=total_distance,
        total_elevation=total_elevation,
    )

    return data


def generate_polyline_from_route(route: CompletedRoute) -> dl.Polyline:
    """For a generated route, generate a dash-leaflet polyline which can be
    displayed on a map

    Args:
        graph: The graph which was used to generate the provided route
        route: A route generated by a RouteMaker

    Returns:
        A mapbox plot of the provided route
    """

    positions = [(lat, lon) for lat, lon in zip(route.lats, route.lons)]

    polyline = dl.Polyline(
        positions=positions, id="route-plot-trace", interactive=True
    )

    return polyline

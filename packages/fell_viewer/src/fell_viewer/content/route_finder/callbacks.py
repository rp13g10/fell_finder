"""Defines a function which can be used to initialize the callbacks used in
the route finder page"""

import json
import os
from typing import Callable, Dict, List, Literal, Tuple, Union

import dash_leaflet as dl
from dash import Input, Output, State, callback, html, no_update
from dash._callback import NoUpdate
from dash.development.base_component import Component
from plotly.graph_objects import Figure

from fell_viewer.app import background_callback_manager
from fell_viewer.containers.config import RouteConfig
from fell_viewer.content.route_finder.generators import (
    generate_elevation_plot,
    generate_route_card,
)
from fell_viewer.utils.api import get_user_requested_route
from fell_viewer.utils.caching import (
    load_routes_from_str,
    store_routes_to_str,
)
from fell_viewer.utils.plotting import (
    generate_polyline_from_route,
)

CUR_DIR = os.path.dirname(os.path.abspath(__file__))

with open(
    os.path.join(CUR_DIR, "highway_types.json"), "r", encoding="utf8"
) as fobj:
    HIGHWAY_TYPES = json.load(fobj)

with open(
    os.path.join(CUR_DIR, "surface_types.json"), "r", encoding="utf8"
) as fobj:
    SURFACE_TYPES = json.load(fobj)


def init_callbacks() -> None:
    """This function needs to be called in a function which defines elements of
    the page config in order to ensure the enclosed callbacks are correctly
    registered"""

    # ruff: noqa: ANN202

    @callback(
        Output("route-plot", "children", allow_duplicate=True),
        Input("route-plot", "clickData"),
        State("route-plot", "children"),
        prevent_initial_call=True,
    )
    def show_clicked_point_on_map(click_data: Dict, current_children: List):
        """Whenever the user clicks a point on the route, add a marker to the
        map at the selected point

        Args:
            click_data: The data generated by Dash to signify a user click
            current_children: The current contents of the primary plot

        Returns:
            The updated contents of the route plot, with the old marker removed
            and a new one added

        """
        if click_data is None:
            return no_update

        lat = click_data["latlng"]["lat"]
        lon = click_data["latlng"]["lng"]

        new_marker = dl.Marker(position=[lat, lon], id="route-plot-marker")

        new_children = [
            child
            for child in current_children
            if child["props"]["id"] != "route-plot-marker"
        ]
        new_children.append(new_marker)

        return new_children

    @callback(
        Output("route-restricted-surfaces", "options"),
        Input("route-allowed-surfaces", "value"),
    )
    def update_restriction_options(route_allowed_surfaces: List[str]):
        return route_allowed_surfaces

    @callback(
        [
            Output("route-store", "data", allow_duplicate=True),
            Output("url", "search"),
        ],
        Input("route-calculate", "n_clicks"),
        [
            State("route-plot", "children"),
            State("route-dist", "value"),
            State("route-mode", "value"),
            State("route-highway", "value"),
            State("route-allowed-surfaces", "value"),
            State("route-restricted-surfaces", "value"),
            State("route-restricted-perc", "value"),
        ],
        background=True,
        prevent_initial_call=True,
        progress=Output("progress-bar", "children"),
        manager=background_callback_manager,
    )
    def calculate_and_store_routes(
        set_progress: Callable,
        n_clicks: Union[int, None],
        current_children: List,
        route_dist: str,
        route_mode: Literal["hilly", "flat"],
        route_highways: List[str],
        route_allowed_surfaces: List[str],
        route_restricted_surfaces: List[str],
        route_restricted_perc: float,
    ) -> Union[Tuple[List[str], str], Tuple[NoUpdate, NoUpdate]]:
        """Based on the user's selection, generate a circular route which meets
        their requirements. Periodically update the progress bar to keep them
        informed.

        Args:
            set_progress: Function provided by dash which can be used to update
              the progress bar as the function executes
            n_clicks: The number of times the calculate button has been clicked
            current_children: The contents of the current route plot
            route_dist: The user requested distance
            route_mode: The user requested mode (hilly/flat)
            route_highways: The user requested highways
            route_allowed_surfaces: The user requested surfaces
            route_restricted_surfaces: Surfaces which are to be restricted to
              a percentage of the total distance
            route_restricted_perc: The max allowed percentage of the total
              distance which can be travelled on the restricted surfaces

        Returns:
            A circular route starting at the selected point

        """
        if not n_clicks:
            return no_update, no_update

        current_marker = next(
            x
            for x in current_children
            if x["props"]["id"] == "route-plot-marker"
        )
        lat, lon = current_marker["props"]["position"]

        max_candidates = int(os.environ["FF_MAX_CANDS"])

        highway_types = []
        for highway_type in route_highways:
            highway_types += HIGHWAY_TYPES[highway_type]

        surface_types = []
        for surface_type in route_allowed_surfaces:
            surface_types += SURFACE_TYPES[surface_type]

        config = RouteConfig(
            start_lat=lat,
            start_lon=lon,
            target_distance=int(route_dist) * 1000,
            route_mode=route_mode,
            max_candidates=max_candidates,
            highway_types=highway_types,
            surface_types=surface_types,
            restricted_surfaces=route_restricted_surfaces,
            restricted_surfaces_perc=route_restricted_perc,
        )

        routes = get_user_requested_route(config)

        routes_str = store_routes_to_str(routes)

        route_id = routes[0].route_id
        query_str = f"?route_id={route_id}"

        return [routes_str], query_str

    @callback(
        [
            Output("route-plot", "children", allow_duplicate=True),
            Output("route-plot", "viewport"),
            Output("route-profile", "figure"),
        ],
        [Input("url", "search")],
        [
            State("route-store", "data"),
            State("route-plot", "children"),
            State("url", "pathname"),
        ],
        prevent_initial_call=True,
    )
    def update_primary_plot(
        search_str: str,
        cached_routes: str,
        current_children: List,
        current_page: str,
    ) -> Union[Tuple[NoUpdate, NoUpdate, NoUpdate], Tuple[List, Dict, Figure]]:
        """When the user selects a new route for display in the primary plot,
        fetch the relevant data and render it as a polyline

        Args:
            search_str: The requested route ID
            cached_routes: The cached route data
            current_children: The current contents of the primary plot
            current_page: The currently selected page

        Returns:
            The updated contents of the primary plot, with any old polylines
            removed and a new one added

        """

        if current_page != "/route_finder":
            return no_update, no_update, no_update

        if not cached_routes:
            return no_update, no_update, no_update

        routes = load_routes_from_str(cached_routes[0])

        if not search_str:
            # User hasn't clicked a route yet, display the first
            route = routes[0]
        else:
            # Display the selected route
            target_id = int(search_str.split("=")[-1])
            route = next(x for x in routes if x.route_id == target_id)

        polyline = generate_polyline_from_route(route)

        viewport = route.geometry.bbox.to_viewport()

        new_children = [
            x
            for x in current_children
            if x["props"]["id"] != "route-plot-trace"
        ]
        new_children.append(polyline)

        profile_plot = generate_elevation_plot(route)

        return new_children, viewport, profile_plot

    @callback(
        Output("route-download", "data"),
        Input("route-download-button", "n_clicks"),
        [
            State("url", "search"),
            State("route-store", "data"),
            State("url", "pathname"),
        ],
        prevent_initial_call=True,
    )
    def download_gpx(
        n_clicks: int,
        search_str: str,
        cached_routes: str,
        current_page: str,
    ) -> dict[str, str] | NoUpdate:
        """When the download GPX button is clicked, generate a GPX file for
        the selected route and trigger a download

        Args:
            n_clicks: The number of button clicks, not accessed
            search_str: The requested route ID
            cached_routes: The cached route data
            current_children: The current contents of the primary plot
            current_page: The currently selected page

        Returns:
            The updated contents of the primary plot, with any old polylines
            removed and a new one added

        """

        if current_page != "/route_finder":
            return no_update

        if not cached_routes:
            return no_update

        if not search_str:
            return no_update

        routes = load_routes_from_str(cached_routes[0])

        # Fetch the selected route
        target_id = search_str.split("=")[-1]
        route = next(x for x in routes if x.route_id == target_id)

        gpx_data = route.geometry.to_gpx()

        dl_data = {"filename": "found_fell.gpx", "content": gpx_data}

        return dl_data

    @callback(
        Output("route-cards", "children"),
        Input("route-store", "data"),
        prevent_initial_call=True,
    )
    def update_route_cards(
        cached_routes: str,
    ) -> Union[List[Component], html.Div]:
        """When new map data is added to the store, render a small card for
        each route which includes a mini-map and a link to view it in more
        detail

        Args:
            cached_routes: The cached route data

        Returns:
            A list of route card elements

        """
        if not cached_routes:
            return html.Div()

        routes = load_routes_from_str(cached_routes[0])

        route_cards = []
        for route in routes:
            route_card = generate_route_card(route)
            route_cards.append(route_card)

        return route_cards

    @callback(
        Output("route-plot", "children", allow_duplicate=True),
        Input("route-profile", "hoverData"),
        State("route-plot", "children"),
        prevent_initial_call=True,
    )
    def update_map_based_on_profile(
        hover_data: Union[Dict, None], current_children: List
    ):
        """When the user hovers over the elevation profile, place a marker on
        the map at the corresponding location.

        Args:
            hover_data: Data on the currently selected point on the profile
            current_children: The current contents of the route plot

        Returns:
            The different layers required to plot the route and the selected
            point on the map

        """
        if hover_data is None:
            return no_update

        lat_lon = hover_data["points"][0]["customdata"]

        route_marker = dl.Marker(position=lat_lon, id="selected-point")

        new_children = [
            x for x in current_children if x["props"]["id"] != "selected-point"
        ]

        new_children.append(route_marker)

        return new_children

    @callback(
        Output("route-dist-display", "children"), Input("route-dist", "value")
    )
    def update_route_dist_display(selected_dist: str):
        """When the user changes the selected distance, update the indicator to
        reflect the new value.

        Args:
            selected_dist: The user selected distance

        Returns:
            A string representation of selected_dist

        """

        output = f"{selected_dist} km"

        return output

    @callback(
        Output("route-restricted-perc-display", "children"),
        Input("route-restricted-perc", "value"),
    )
    def update_restricted_perc_display(restricted_perc: str):
        """When the user changes the selected % surface restriction, update
        the indicator the reflect the new value.

        Args:
            restricted_perc: The user selected % restriction

        Returns:
            A string representation of restricted_perc

        """
        restricted_val = float(restricted_perc)
        output = f"{restricted_val:,.2%}"

        return output

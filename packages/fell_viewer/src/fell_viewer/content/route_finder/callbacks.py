"""Defines a function which can be used to initialize the callbacks used in
the route finder page"""

import json
import os
from typing import Dict, List, Literal, Tuple, Union

import dash_bootstrap_components as dbc
import dash_leaflet as dl
from dash import ALL, Input, Output, State, callback, ctx, no_update
from dash._callback import NoUpdate  # type: ignore
from plotly.graph_objects import Figure

from fell_viewer.common.app import background_callback_manager
from fell_viewer.common.containers import RouteConfig
from fell_viewer.common.icons import MAP_PIN_PNG, ROUTE_START_PNG
from fell_viewer.content.route_finder.components.cards import RouteCard
from fell_viewer.content.route_finder.generators import (
    generate_elevation_plot,
)
from fell_viewer.utils.api import get_user_requested_route
from fell_viewer.utils.caching import (
    load_routes_from_str,
    store_routes_to_str,
)

CUR_DIR = os.path.dirname(os.path.abspath(__file__))


with open(
    os.path.join(CUR_DIR, "highway_types.json"), "r", encoding="utf8"
) as fobj:
    HIGHWAY_TYPES = json.load(fobj)

with open(
    os.path.join(CUR_DIR, "surface_types.json"), "r", encoding="utf8"
) as fobj:
    SURFACE_TYPES = json.load(fobj)


def init_callbacks() -> None:
    """This function needs to be called in a function which defines elements of
    the page config in order to ensure the enclosed callbacks are correctly
    registered"""

    # ruff: noqa: ANN202

    @callback(
        Output("route-plot", "children", allow_duplicate=True),
        Input("route-plot", "clickData"),
        State("route-plot", "children"),
        prevent_initial_call=True,
    )
    def show_clicked_point_on_map(click_data: Dict, current_children: List):
        """Whenever the user clicks a point on the route, add a marker to the
        map at the selected point

        Args:
            click_data: The data generated by Dash to signify a user click
            current_children: The current contents of the primary plot

        Returns:
            The updated contents of the route plot, with the old marker removed
            and a new one added

        """
        if click_data is None:
            return no_update

        lat = click_data["latlng"]["lat"]
        lon = click_data["latlng"]["lng"]

        iconurl = f"data:/image/png;base64,{ROUTE_START_PNG.decode('utf8')}"
        new_marker = dl.Marker(
            position=[lat, lon],  # type: ignore
            id="route-plot-marker",
            icon={
                "iconUrl": iconurl,
                "iconSize": [48, 48],
                "iconAnchor": [24, 48],
            },
        )

        new_children = [
            child
            for child in current_children
            if child["props"]["id"] != "route-plot-marker"
        ]
        new_children.append(new_marker)

        return new_children

    @callback(
        Output("route-restricted-surfaces", "options"),
        Input("route-allowed-surfaces", "value"),
    )
    def update_restriction_options(route_allowed_surfaces: List[str]):
        return route_allowed_surfaces

    @callback(
        [
            Output("route-store", "data", allow_duplicate=True),
        ],
        Input("route-calculate-button", "n_clicks"),
        [
            State("route-plot", "children"),
            State("route-dist", "value"),
            State("route-mode", "value"),
            State("route-highway", "value"),
            State("route-allowed-surfaces", "value"),
            State("route-restricted-surfaces", "value"),
            State("route-restricted-perc", "value"),
        ],
        background=True,
        prevent_initial_call=True,
        manager=background_callback_manager,
    )
    def calculate_and_store_routes(
        n_clicks: Union[int, None],
        current_children: List,
        route_dist: str,
        route_mode: Literal["hilly", "flat"],
        route_highways: List[str],
        route_allowed_surfaces: List[str],
        route_restricted_surfaces: List[str],
        route_restricted_perc: int,
    ) -> List[str] | NoUpdate:
        """Based on the user's selection, generate a circular route which meets
        their requirements. Periodically update the progress bar to keep them
        informed.

        Args:
            n_clicks: The number of times the calculate button has been clicked
            current_children: The contents of the current route plot
            route_dist: The user requested distance
            route_mode: The user requested mode (hilly/flat)
            route_highways: The user requested highways
            route_allowed_surfaces: The user requested surfaces
            route_restricted_surfaces: Surfaces which are to be restricted to
              a percentage of the total distance
            route_restricted_perc: The max allowed percentage of the total
              distance which can be travelled on the restricted surfaces

        Returns:
            A circular route starting at the selected point

        """

        # TODO: Bring back the progress bar

        if not n_clicks:
            return no_update

        current_marker = next(
            x
            for x in current_children
            if x["props"]["id"] == "route-plot-marker"
        )
        lat, lon = current_marker["props"]["position"]

        max_candidates = int(os.environ["FF_MAX_CANDS"])

        highway_types = []
        for highway_type in route_highways:
            highway_types += HIGHWAY_TYPES[highway_type]

        surface_types = []
        for surface_type in route_allowed_surfaces:
            surface_types += SURFACE_TYPES[surface_type]

        restricted_surfaces = []
        for surface_type in route_restricted_surfaces:
            restricted_surfaces += SURFACE_TYPES[surface_type]

        config = RouteConfig(
            start_lat=lat,
            start_lon=lon,
            target_distance=int(route_dist) * 1000,
            route_mode=route_mode,
            max_candidates=max_candidates,
            highway_types=highway_types,
            surface_types=surface_types,
            restricted_surfaces=restricted_surfaces,
            restricted_surfaces_perc=route_restricted_perc / 100.0,
        )

        routes = get_user_requested_route(config)

        routes_str = store_routes_to_str(routes)

        return [routes_str]

    @callback(
        [
            Output("route-tabs", "active_tab"),
            Output("route-cards", "children"),
        ],
        Input("route-store", "data"),
        prevent_initial_call=True,
    )
    def select_view_tab_and_render_cards(
        cached_routes: str,
    ) -> tuple[NoUpdate, NoUpdate] | tuple[str, list[dbc.Card]]:
        if not cached_routes:
            return no_update, no_update

        new_routes = load_routes_from_str(cached_routes)

        cards = [RouteCard(route).generate() for route in new_routes]

        return "route-tab-cards", cards

    @callback(
        [
            Output("route-plot", "children", allow_duplicate=True),
            Output("route-plot", "viewport", allow_duplicate=True),
            Output("route-profile", "figure", allow_duplicate=True),
        ],
        Input("route-store", "data"),
        State("route-plot", "children"),
        prevent_initial_call=True,
    )
    def update_primary_plot_on_calculation(
        cached_routes: str, current_children: list
    ) -> Union[Tuple[NoUpdate, NoUpdate, NoUpdate], Tuple[List, Dict, Figure]]:
        """When the user selects a new route for display in the primary plot,
        fetch the relevant data and render it as a polyline

        Args:
            search_str: The requested route ID
            cached_routes: The cached route data
            current_children: The current contents of the primary plot
            current_page: The currently selected page

        Returns:
            The updated contents of the primary plot, with any old polylines
            removed and a new one added

        """

        if not cached_routes:
            return no_update, no_update, no_update

        new_routes = load_routes_from_str(cached_routes)

        route = new_routes[0]

        polyline = route.to_polyline(id="route-plot-trace")

        viewport = route.geometry.bbox.to_viewport()

        new_children = [
            x
            for x in current_children
            if x["props"]["id"] != "route-plot-trace"
        ]
        new_children.append(polyline)

        profile_plot = generate_elevation_plot(route)

        return new_children, viewport, profile_plot

    @callback(
        [
            Output("route-plot", "children", allow_duplicate=True),
            Output("route-plot", "viewport", allow_duplicate=True),
            Output("route-profile", "figure", allow_duplicate=True),
        ],
        Input({"type": "route-view-button", "route-id": ALL}, "n_clicks"),
        [
            State({"type": "route-view-button", "route-id": ALL}, "id"),
            State("route-store", "data"),
            State("route-plot", "children"),
        ],
        prevent_initial_call=True,
    )
    def update_primary_plot_on_view_click(
        all_n_clicks: list[int],
        all_ids: list[dict],
        cached_routes: str,
        current_children: list,
    ) -> tuple[NoUpdate, NoUpdate, NoUpdate] | tuple[list, dict, Figure]:
        """When the user selects a new route for display in the primary plot,
        fetch the relevant data and render it as a polyline

        Args:
            all_n_clicks: The number of clicks for all of the 'View' buttons
                on route cards
            all_ids: The IDs for all of the 'View' buttons on route
                cards
            cached_routes: The contents of the route cache, a JSON encoded
                string containing the details of all generated routes
            current_children: The current contents of the primary plot

        Returns:
            The updated contents of the primary plot, with any old polylines
            removed and a new one added

        """

        # TODO: Switch this over to using partial updates if appropriate

        # Determine which route was clicked
        if not ctx.triggered_id:
            raise ValueError("Something went wrong updating the plot")
        target_id = ctx.triggered_id["route-id"]

        # Get the number of clicks for the selected route
        n_clicks = 0
        for maybe_n_clicks, maybe_route_id in zip(all_n_clicks, all_ids):
            if maybe_route_id["route-id"] == target_id:
                n_clicks = maybe_n_clicks
                break

        if (not n_clicks) or (not cached_routes):
            return no_update, no_update, no_update

        routes = load_routes_from_str(cached_routes)

        # Fetch the selected route
        route = next(x for x in routes if str(x.route_id) == target_id)

        polyline = route.to_polyline(id="route-plot-trace")

        viewport = route.geometry.bbox.to_viewport()

        # Clear out the old polyline & markers, retain the tile layer
        new_children = [
            x
            for x in current_children
            if x["props"]["id"] not in {"route-plot-trace", "selected-point"}
        ]
        new_children.append(polyline)

        profile_plot = generate_elevation_plot(route)

        return new_children, viewport, profile_plot

    @callback(
        Output("route-download", "data"),
        Input({"type": "route-dl-button", "route-id": ALL}, "n_clicks"),
        [
            State({"type": "route-dl-button", "route-id": ALL}, "id"),
            State("route-store", "data"),
        ],
        prevent_initial_call=True,
    )
    def download_gpx_on_dl_click(
        all_n_clicks: list[int], all_ids: list[dict], cached_routes: str
    ) -> NoUpdate | dict[str, str]:
        """When the user selects a new route for display in the primary plot,
        fetch the relevant data and render it as a polyline

        Args:
            all_n_clicks: The number of clicks for all of the 'View' buttons
                on route cards
            all_ids: The IDs for all of the 'View' buttons on route
                cards
            cached_routes: The contents of the route cache, a JSON encoded
                string containing the details of all generated routes

        Returns:
            The details of a GPX file to trigger a download for

        """

        # Determine which route was clicked
        if not ctx.triggered_id:
            raise ValueError("Something went wrong updating the plot")
        target_id = ctx.triggered_id["route-id"]

        # Get the number of clicks for the selected route
        n_clicks = 0
        for maybe_n_clicks, maybe_route_id in zip(all_n_clicks, all_ids):
            if maybe_route_id["route-id"] == target_id:
                n_clicks = maybe_n_clicks
                break

        if (not n_clicks) or (not cached_routes):
            return no_update

        routes = load_routes_from_str(cached_routes)

        # Fetch the selected route
        route = next(x for x in routes if str(x.route_id) == target_id)

        gpx_data = route.geometry.to_gpx()

        dl_data = {
            "filename": f"found-fell-{target_id}.gpx",
            "content": gpx_data,
        }

        return dl_data

    @callback(
        Output("route-plot", "children", allow_duplicate=True),
        Input("route-profile", "hoverData"),
        State("route-plot", "children"),
        prevent_initial_call=True,
    )
    def update_map_based_on_profile(
        hover_data: Union[Dict, None], current_children: List
    ):
        """When the user hovers over the elevation profile, place a marker on
        the map at the corresponding location.

        Args:
            hover_data: Data on the currently selected point on the profile
            current_children: The current contents of the route plot

        Returns:
            The different layers required to plot the route and the selected
            point on the map

        """
        if hover_data is None:
            return no_update

        lat_lon = hover_data["points"][0]["customdata"]

        iconurl = f"data:/image/png;base64,{MAP_PIN_PNG.decode('utf8')}"
        route_marker = dl.Marker(
            position=lat_lon,
            id="selected-point",
            icon={
                "iconUrl": iconurl,
                "iconSize": [48, 48],
                "iconAnchor": [24, 48],
            },
        )

        new_children = [
            x for x in current_children if x["props"]["id"] != "selected-point"
        ]

        new_children.append(route_marker)

        return new_children
